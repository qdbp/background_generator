import subprocess as sbp
import sys
import time
import tempfile as tmp

import numpy as np
from PIL import Image

def gray_rotor(rate):
    while True:
        for i in range(2**rate):
            yield 0
        for i in range(2*2**rate):
            yield 1
        for i in range(2**rate):
            yield 0


def gray_engine(l):
    rotors = [gray_rotor(x) for x in range(l)]
    i = 0
    while i < 2**l:
        yield [next(rotor) for rotor in rotors]
        i += 1


def woven_outp(l, ndim, dg_from_b, pack=True, **kwargs):
    dim = [2**l for _ in range(ndim)] + [l*ndim]
    out = np.zeros(l*ndim*(2**l)**ndim, dtype=np.uint8).reshape(tuple(dim))

    grays = np.asarray(list(gray_engine(l)))

    for bit in range(l*ndim):
        dim, gix = dg_from_b(l, ndim, bit, **kwargs)

        broadcast_slice = [np.newaxis for _ in range(ndim)]
        broadcast_slice[dim] = slice(None, None)
        out[..., bit] = grays[:, gix][tuple(broadcast_slice)]

    if pack:
        return np.packbits(out, axis=-1)
    else:
        return out


def dg_pseudo_hadamard(l, ndim, bit, c2h_skip=3, c2h_seg_len=8, primacy=[0, 1, 2],
                       random=False):
    '''
    as in the original graygrid
    '''
    # this table gives the bit from the pseudo-hadamard layout
    # corresponding to the given colour bit

    # the out table being generated by woven_outp has bits directly
    # corresponding to colours; hence we need this table to find the correct
    # gray line to use,
    # effectively inverting the get_sample table of the original graygrid
    # (which took the hadamard bits and extracted the colour triple)
 
    assert c2h_skip * c2h_seg_len == l*ndim
    assert len(primacy) == c2h_skip

    if not random:
        col_to_hada = {}
        for px, p in enumerate(primacy):
            col_to_hada.update({i + c2h_seg_len*px: c2h_skip*i + p for i in range(c2h_seg_len)})
    else:
        perm = np.random.permutation(l*ndim)
        col_to_hada = {i: perm[i] for i in range(l*ndim)}

    hada_bit = col_to_hada[bit]
    nix = hada_bit - l*ndim
    dim = nix % ndim
    gix = l - hada_bit // ndim - 1

    return (dim, gix)


def main():

    try:
        wait = float(sys.argv[1])
        assert wait > 0
    except (ValueError, IndexError, AssertionError):
        wait = None

    while True:
        out = woven_outp(12, 2, dg_pseudo_hadamard, pack=True, random=True)
        img = Image.fromarray(out, mode='RGB')

        with tmp.NamedTemporaryFile() as f:
            # f, fn = tmp.mkstemp()
            img.save(f.name, format='png')
            sbp.run(['feh', '--bg-tile', f.name])

        if wait is None:
            return
        else:
            time.sleep(wait)


if __name__ == '__main__':
    main()
