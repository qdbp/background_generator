import sys
import numpy as np

from PIL import Image

def gray_rotor(rate):
    while True:
        for i in range(2**rate):
            yield 0
        for i in range(2*2**rate):
            yield 1
        for i in range(2**rate):
            yield 0


def gray_engine(l):
    rotors = [gray_rotor(x) for x in range(l)]
    i = 0
    while i < 2**l:
        yield [next(rotor) for rotor in rotors]
        i += 1


def woven_outp(l, ndim, dg_from_b, pack=True, **kwargs):
    dim = [2**l for _ in range(ndim)] + [l*ndim]
    out = np.zeros(l*ndim*(2**l)**ndim, dtype=np.uint8).reshape(tuple(dim))

    grays = np.asarray(list(gray_engine(l)))

    for bit in range(l*ndim):
        dim, gix = dg_from_b(l, ndim, bit, **kwargs)

        broadcast_slice = [np.newaxis for _ in range(ndim)]
        broadcast_slice[dim] = slice(None, None)
        out[..., bit] = grays[:, gix][tuple(broadcast_slice)]

    if pack:
        return np.packbits(out, axis=-1)
    else:
        return out


def dg_from_b_append(l, ndim, bit):
    dim = bit // l
    gix = bit % l
    return (dim, gix)


def dg_from_b_append_rd(l, ndim, bit):
    dim = ndim - bit // l - 1
    gix = bit % l
    return (dim, gix)


def dg_from_b_append_rg(l, ndim, bit):
    dim = (bit // 2) % ndim
    gix = l - bit % l - 1
    return (dim, gix)


def dg_from_b_append_rdg(l, ndim, bit):
    dim = ndim - bit // l - 1
    gix = l - bit % l - 1
    return (dim, gix)


def dg_pseudo_hadamard(l, ndim, bit, c2h_skip=3, c2h_seg_len=8, primacy=[0, 1, 2],
                       random=False):
    '''
    as in the original graygrid
    '''
    # this table gives the bit from the pseudo-hadamard layout
    # corresponding to the given colour bit

    # the out table being generated by woven_outp has bits directly
    # corresponding to colours; hence we need this table to find the correct
    # gray line to use,
    # effectively inverting the get_sample table of the original graygrid
    # (which took the hadamard bits and extracted the colour triple)
 
    assert c2h_skip * c2h_seg_len == l*ndim
    assert len(primacy) == c2h_skip

    if not random:
        col_to_hada = {}
        for px, p in enumerate(primacy):
            col_to_hada.update({i + c2h_seg_len*px: c2h_skip*i + p for i in range(c2h_seg_len)})
        print(col_to_hada)
    else:
        perm = np.random.permutation(l*ndim)
        col_to_hada = {i: perm[i] for i in range(l*ndim)}

    hada_bit = col_to_hada[bit]
    nix = hada_bit - l*ndim
    dim = nix % ndim
    # gix = nix // ndim + 1
    gix = l - hada_bit // ndim - 1

    print(bit, hada_bit, nix)
    print(dim, gix)

    return (dim, gix)

for i in range(100):
    print(i)
    out = woven_outp(12, 2, dg_pseudo_hadamard, pack=True, random=True)
    
    img = Image.fromarray(out, mode='RGB')
    img.save('test_random_{}.png'.format(i))

# primacies = [[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]]
# for px, pr in enumerate(primacies):
#     out = woven_outp(12, 2, dg_pseudo_hadamard, pack=True,
#                      primacy=pr)
#     img = Image.fromarray(out, mode='HSV')
#     img.save('test6_{}.png'.format(px))
